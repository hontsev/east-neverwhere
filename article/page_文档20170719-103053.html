<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>乌有乡 - East Neverwhere</title>

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
	<link href="../css/sixsquarestyle.css" rel="stylesheet">
	<link href="../css/mystyle.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body style="background-color:#000;background-image:url(../image/bg.jpg);background-repeat:no-repeat; background-attachment:fixed;background-size:cover">
  <nav class="navbar navbar-inverse" role="navigation">
   <div class="navbar-header">
      <a class="navbar-brand" href="/">乌有乡 - East Neverwhere</a>
   </div>
   <div>
      <ul class="nav navbar-nav" id='menubar'></ul>
   </div>
</nav>
      <div class="container">
	  <div class="col-md-12" style="padding-bottom:60px">
			<h2 class="form-signin-heading" style="color:#fff"><b>文档20170719-103053</b></h2>
		</div>		
	  <div class="col-md-12">
	  	<div class="col-md-12 text pull-right" >
			<p>虚拟人形开发日志</p><p>&nbsp;</p><p>内部逻辑类似于一个语义网络，但是有以下特点：</p><p>1&nbsp;并不自发地将同名的单元归为同一事物，而只是在同一个上下文中出现的同名单元才归为同一事物。</p><p>2&nbsp;在进行单元匹配查询时，将所有同名单元都查询出来，也就是说，每次查询返回的都是一个集合而不是单个</p><p>3&nbsp;每个单元有一个是否启用的标记，当删除一个单元时，是软删除，将标记置为不启用。同时，每个单元在录入系统时都将记录其录入人和录入时间，以此来提供额外的决策依据信息。</p><p>&nbsp;</p><p>语义与语法分开讨论，这就意味着语法的自学习过程完全独立开来，同时在对句子进行语法判断的时候，也不再考虑句中词语的语义含义如何。语法分析器的提交结果是一个内部语言所写的语义操作指令。</p><p>&nbsp;</p><p>内部语言</p><p>语义系统的沟通方式通过一种类似于sql语句的方式来实现。假设变元a，b，c，则构建以下规则</p><p>1&nbsp;=（ab），表示单元a和单元b之间构建全等关系，允许对于其中一个元素的检索同时带上另外一个元素，并将约束条件视同使用。</p><p>2&nbsp;<（ab），表示单元a属于单元b的特例，用于约束条件的推及</p><p>&nbsp;</p><p>系统中的语义网络的抽象数据结构可以视为一个带权重边的无向图。节点代表了一个个具体的意义单元，而不同的边代表着二者关系是一种怎样的关系。</p><p>最简单的同义词关系可以通过同义边来关联，被用此边关联了的两个单元被视作是可以进行相同操作的等价节点。</p><p>关于语言的常见的谓词句式（主谓宾结构），主谓或者谓宾关系是一种有向关系，也即主谓位置不能互换。在这种情况下，无向边就不能够用来描述此种关联。因此，我们考虑这种主谓宾的表示采用带有位置标记的权重边来完成，也即双方都能直接搜到另一个节点，但是双方在节点记录中标记出本节点在关联中扮演哪个角色。</p><p>此外，传统的语义网络将一切同名元素合并，造成了不同句子的结构被合并在了一起，无法只根据图结构来搜索出哪些关联序列是从属于同一个句子的，这会造成原始数据有所损失。因此，这里采取的办法是，在每一个节点和关系中记录其所属的上下文标记，这个上下文标记是一个单独的记录，表示了该条记录添加入网络时所属的时间，添加者，以及可能会有的其他辅助信息。这保证了不同时刻的不同句子都各自独立存储为一个单独的图结构，而跨上下文的语义检索必须借由等同规则或从属规则来搭桥完成。</p><p>除了主谓宾结构，句子中还有很多助词和副词，它们依然属于语义表达的一部分，必须存储。由于这些词语虽然处于辅助位置，但是依然分别代表了一些单独的意义元素，因此将之可以各自视为额外节点，将之通过形容的关联来连接到相关的叙述主体上。</p><p>对于有子句结构的复杂复句，在语法层面上将其拆分成一系列的简单句即可。如果主语或者宾语并非单个元素，则将关联的落脚点落在一个特定的谓词上。</p><p>&nbsp;</p>
		</div>
		
	  </div>
	  

    </div> <!-- /container -->
    <script src="/js/jquery-1.12.0.min.js"></script>
	<script src="/js/jquery.goup.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
	<script src="/js/menubar.js"></script>
	<script>
	 $(document).ready(function () {
 
            $.goup({
                trigger: 100,
                bottomOffset: 150,
                locationOffset: 100,
            });
 
        });
	</script>
	
  </body>
</html>